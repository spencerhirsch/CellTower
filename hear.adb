-- Authors: Spencer Hirsch, shirsch2020@my.fit.edu
--          Tyler Gutowski, tgutowski2020@my.fit.edu
-- Course:  CSE 4250, Fall 2022
-- Project: Project 3, Can you HEAR me now?

WITH ADA.TEXT_IO;
WITH ADA.TEXT_IO.UNBOUNDED_IO;
WITH ADA.STRINGS;
WITH ADA.STRINGS.FIXED;
WITH ADA.INTEGER_TEXT_IO;
WITH ADA.CONTAINERS.DOUBLY_LINKED_LISTS;
WITH ADA.STRINGS.UNBOUNDED;
USE ADA.STRINGS.UNBOUNDED;
--WITH GRAPH;


-- MAIN PROCEDURE THAT HANDLES ALL OF THE DATA PROCESSING.
-- TAKES INPUT FROM THE USER AND PROCESSES IT ACCORDINGLY.
-- CALLS THE GRAPH FUNCTIONS ACCORDING TO USER INPUT.

PROCEDURE HEAR IS
TYPE TOWERS;								-- DECLARE TYPE
TYPE TOWERS_ACCESS IS ACCESS TOWERS; 		-- REFERNCE TO THE TYPE

-- INITIALIZE DOUBLY LINKED LIST OF TYPE TOWER_ACCESS
PACKAGE LINKS IS NEW ADA.CONTAINERS.DOUBLY_LINKED_LISTS(TOWERS_ACCESS);
USE LINKS;

-- TYPE THAT STORES THE NECESSARY DATA FOR EACH TOWER
-- EACH TOWER HAS A SOURCE AND A LIST OF CONNECTING TOWERS
TYPE TOWERS IS RECORD
	SOURCE : UNBOUNDED_STRING;
	LINK : LIST; 			 				-- LIST OF TOWER_ACCESS
	CHECKED : BOOLEAN := FALSE;
END RECORD;	

-- DECLARE LIST WITHIN SCOPE OF MAIN PROCEDURE
SOURCES : LIST;

SUBTYPE POSITION IS INTEGER RANGE 0 .. 150;
ALREADY_PRINTED_DFS: BOOLEAN                 := FALSE;
IS_VALID_INPUT     : BOOLEAN                 := TRUE;
LAST               : NATURAL;
FOREVER            : BOOLEAN                 := TRUE;
ARRAY_SIZE         : INTEGER                 := 150;
INPUT              : STRING(1..ARRAY_SIZE);
TOWER_FIRST_START  : POSITION; -- A
TOWER_FIRST_END    : POSITION; -- B
TOWER_SECOND_START : POSITION; -- C
TOWER_SECOND_END   : POSITION; -- D
COMMAND_INDEX      : POSITION; -- E

COMMAND            : CHARACTER;


	-- RETURNS BOOLEAN GIVEN THE NAME OF THE SOURCE. CHECKS TO SEE IF SOURCE
	-- EXISTS WITHIN THE SOURCE LIST
	FUNCTION EXISTS_IN_SOURCE (TOWER_FIRST_NAME : STRING) RETURN BOOLEAN IS
	EXISTS : BOOLEAN := FALSE;
	CURRENT_CURSOR : CURSOR;
	CURRENT_TOWER : TOWERS_ACCESS;
	IS_EMPTY_LIST : BOOLEAN := FALSE;
	BEGIN
		IS_EMPTY_LIST := IS_EMPTY(SOURCES);
		IF IS_EMPTY_LIST THEN
			RETURN EXISTS;
		END IF;
		CURRENT_CURSOR := FIRST(SOURCES);
		FOR I IN 1..LENGTH(SOURCES) LOOP
			CURRENT_TOWER := ELEMENT(CURRENT_CURSOR);
			IF CURRENT_TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) THEN
				EXISTS := TRUE;
				RETURN EXISTS;
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN EXISTS;
	END EXISTS_IN_SOURCE;
	

	-- RETURNS TOWER_ACCESS TYPE GIVEN THE FIRST NAME OF THE SOURCE
	FUNCTION GET_FROM_SOURCE ( TOWER_FIRST_NAME : STRING ) RETURN TOWERS_ACCESS IS
	CURRENT_CURSOR : CURSOR;
	CURRENT_TOWER : TOWERS_ACCESS := NULL;
	BEGIN
		CURRENT_CURSOR := FIRST(SOURCES);
		FOR I IN 1..LENGTH(SOURCES) LOOP
			CURRENT_TOWER := ELEMENT(CURRENT_CURSOR);
			IF CURRENT_TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) THEN
				RETURN CURRENT_TOWER;
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN NULL;
	END GET_FROM_SOURCE;
	--t2 > t3
	--t3 > t4
	--t2 ? t4
	--
	PROCEDURE DFS (TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING; TRUE_TOWER_FIRST_NAME : STRING) IS
	CURRENT : TOWERS_ACCESS;
	BEGIN
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME); -- FIND THE SOURCE TOWER OBJECT
		
		CURRENT.CHECKED := TRUE;
		-- PASS CONDITION
		IF CURRENT.SOURCE = TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) AND ALREADY_PRINTED_DFS = FALSE  THEN -- IF YOU ARE SEARCHING THE TOWER YOU WANT
			ADA.TEXT_IO.PUT_LINE("+ " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
			ALREADY_PRINTED_DFS := TRUE;
		
		-- RECURSE
		ELSE
			FOR TOWER OF CURRENT.LINK LOOP -- FOR ALL LINKS IN SOURCE
				IF NOT TOWER.CHECKED THEN -- IF THE LINK HASN'T BEEN CHECKED
					IF GET_FROM_SOURCE(TO_STRING(TOWER.SOURCE)) = NULL AND ALREADY_PRINTED_DFS = FALSE  THEN -- IF WE ARE AT THE END OF THE LINE OR TOWER DOESNT EXIST
						IF TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) THEN -- IF WE ARE AT END
							ADA.TEXT_IO.PUT_LINE("+ " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
							ALREADY_PRINTED_DFS := TRUE;
						END IF;
					ELSIF ALREADY_PRINTED_DFS = FALSE THEN -- IF TOWER DOES EXIST, WE ARE NOT AT THE END. CONTINUE RECURSING.
						DFS(TO_STRING(TOWER.SOURCE), TOWER_SECOND_NAME, TRUE_TOWER_FIRST_NAME);
					END IF;
				END IF;
			END LOOP;
		END IF;
		
		-- IF YOU ARE AT THE ROOT TOWER AND YOU HAVENT PRINTED ALREADY
		IF TOWER_FIRST_NAME = TRUE_TOWER_FIRST_NAME AND ALREADY_PRINTED_DFS = FALSE THEN
			ADA.TEXT_IO.PUT_LINE("- " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
		END IF;
	END DFS;


	-- GIVEN A SOURCE NAME AND A DESTINATION NAME, THIS FUNCTION CHECKS TO SEE IF A CONNECTING TOWER
	-- IS A DIRECT CONNECTION WITH THE SOURCE TOWER. RETURNS A BOOLEAN IF THE CONNECTING TOWER IS
	-- CONTAINED WITHIN THE LIST IN THE TOWERS_ACCESS RECORD
	FUNCTION CHECK_TOWER_LIST(TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING) RETURN BOOLEAN IS
	FOUND : BOOLEAN := FALSE;
	CURRENT_CURSOR : CURSOR;
	CURRENT : TOWERS_ACCESS;
	CURRENT_IN_TOWER : TOWERS_ACCESS;
	BEGIN
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME);
		CURRENT_CURSOR := CURRENT.LINK.FIRST;
		FOR I IN 1..LENGTH(CURRENT.LINK) LOOP
			CURRENT_IN_TOWER := ELEMENT(CURRENT_CURSOR);
			--ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(CURRENT_IN_TOWER.SOURCE);
			IF TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) = CURRENT_IN_TOWER.SOURCE THEN
				FOUND := TRUE;
				RETURN FOUND;
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN FOUND;
	END CHECK_TOWER_LIST;


	-- FUNCTION USED TO CHECK ALL POSSIBLE CONNECTS FROM A PARENT SOURCE
	-- EXAMPLE INPUT:
	-- TOWER1 TOWER2 .
	-- TOWER2 TOWER3 .
	-- TOWER1 TOWER3 ? SHOULD RETURN:
	-- + TOWER1 => TOWER3
	-- THIS FUNCTION COVERS THAT CASE A RETURNS
	-- @PARAM DOES_EXIST OF TYPE BOOLEAN
	FUNCTION CHECK_ALL_POSSIBLE(TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING) RETURN BOOLEAN IS
		DOES_EXIST : BOOLEAN := FALSE;
		CURRENT_CURSOR : CURSOR;
		CURRENT : TOWERS_ACCESS;
	BEGIN
	
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME);
		CURRENT_CURSOR := CURRENT.LINK.FIRST;
		FOR I IN 1..LENGTH(CURRENT.LINK) LOOP
			CURRENT := ELEMENT(CURRENT_CURSOR);
			DOES_EXIST := CHECK_TOWER_LIST(TO_STRING(CURRENT.SOURCE), TOWER_SECOND_NAME);
			IF DOES_EXIST THEN
				RETURN DOES_EXIST;
			END IF;
		END LOOP;
		RETURN DOES_EXIST;

	END CHECK_ALL_POSSIBLE;

	-- PROCEDURE USED TO PROCESS THE INPUT ACCORDINGLY. AFTER THE INPUT IS 
	-- BROKEN APART. THIS PROCEDURE CALLS THE NECESSARY GRAPH OPERATIONS TO
	-- EITHER PROMPT OUTPUT OR TO ADD NEW RECORD TO THE GRAPH.
    PROCEDURE PROCESS_STRING( TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING; COMMAND : CHARACTER ) IS
	LINK_FOUND : BOOLEAN := FALSE;
	TOWER_SOURCE : TOWERS_ACCESS := NEW TOWERS;
	TOWER_CONNECTED : TOWERS_ACCESS := NEW TOWERS;
	FIRST_TOWER_EXISTS : BOOLEAN;
	BEGIN
		-- IF USER PROMPTED FOR ADDITION TO GRAPH.
		IF COMMAND = '.' THEN
			FIRST_TOWER_EXISTS := EXISTS_IN_SOURCE(TOWER_FIRST_NAME);
			-- SECOND_TOWER_EXISTS := EXISTS_IN_SOURCE(TOWER_SECOND_NAME); 		-- MIGHT NOT NEED
			IF FIRST_TOWER_EXISTS THEN
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE("ADDING " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " TO " & TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & "'S LINKS");
				TOWER_CONNECTED.SOURCE := TO_UNBOUNDED_STRING(TOWER_SECOND_NAME);
				TOWER_SOURCE := GET_FROM_SOURCE(TOWER_FIRST_NAME);
				TOWER_SOURCE.LINK.APPEND(TOWER_CONNECTED);
				
				-- RETRIEVE ELEMENT RECORD FROM SOURCES LIST TO EDIT
				-- ADD CONNECTING TOWER TO RECORD LIST
			ELSE
				TOWER_SOURCE.SOURCE := TO_UNBOUNDED_STRING(TOWER_FIRST_NAME);		
				TOWER_CONNECTED.SOURCE := TO_UNBOUNDED_STRING(TOWER_SECOND_NAME);
				TOWER_SOURCE.LINK.APPEND(TOWER_CONNECTED);
				SOURCES.APPEND(TOWER_SOURCE);
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE("ADDING " & TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " AND " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " TO GENERAL SOURCE LIST");
			END IF;

			-- SEARCH FOR TOWER_SECCOND NAME
			-- IF EXISTS, COPY CONTENTS INTO ELEMENT_ACCESS AND STORE IN SOURCE RECORD

			-- ELSE
				-- CREATE NEW RECORD FOR CONNECTING TOWER, ADD TO SOURCE RECORD

		ELSIF COMMAND = '?' THEN
			FIRST_TOWER_EXISTS := EXISTS_IN_SOURCE(TOWER_FIRST_NAME);
			IF NOT FIRST_TOWER_EXISTS THEN -- IF FIRST TOWER ISNT IN SOURCE, IT DOENST EXIST!
				ADA.TEXT_IO.PUT_LINE("- " & TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME); 
			ELSIF TOWER_FIRST_NAME = TOWER_SECOND_NAME THEN -- IF BOTH TOWERS ARE THE SAME TOWER
				ADA.TEXT_IO.PUT_LINE("+ " & TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
			ELSE
				DFS(TOWER_FIRST_NAME, TOWER_SECOND_NAME, TOWER_FIRST_NAME);

						--NULL;
					--SEARCH ALL CONNECTIONS
			END IF;
			--IF FIRST_TOWER_EXISTS AND SECOND_TOWER_EXISTS THEN
			--	TOWER_SOURCE := GET_FROM_SOURCE(TOWER_FIRST_NAME);
			--	TOWER_CONNECTED := GET_FROM_SOURCE(TOWER_SECOND_NAME);
			--	IF DO_TOWERS_CONNECT(TOWER_SOURCE, TOWER_CONNECTED) THEN
					-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " IS LINKED TO " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME));
			--	ELSE
					-- ADA.TEXT_IO.PUT_LINE("BOTH TOWERS EXIST, BUT THEY DO NOT CONNECT");
			--	END IF;
			--ELSIF FIRST_TOWER_EXISTS AND NOT SECOND_TOWER_EXISTS THEN -- T1 BUT NOT T2
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " DOESNT EXIST");
		--	ELSIF NOT FIRST_TOWER_EXISTS AND SECOND_TOWER_EXISTS THEN -- NOT T1 BUT T2
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " DOESNT EXIST");
		--	ELSIF NOT FIRST_TOWER_EXISTS AND NOT SECOND_TOWER_EXISTS THEN
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE("NEITHER " & TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " NOR " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " EXIST");
		--	END IF;
			-- SEARCH FOR CONNECTION IN SOURCE LIST			
		END IF;
    END PROCESS_STRING;


    -- ########################################################################
    -- RETURNS THE INDEX OF WHERE A TOWER STARTS
	FUNCTION GET_TOWER_START( INPUT : STRING; START_INDEX : POSITION) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..150 LOOP
			IF INPUT(I) /= ' ' THEN
				RETURN I;
			END IF;
		END LOOP;
	RETURN 0;
	END GET_TOWER_START;
	
	
    -- ########################################################################
    -- RETURNS THE INDEX OF WHERE A TOWER ENDS
	FUNCTION GET_TOWER_END( INPUT : STRING; START_INDEX : POSITION) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..150 LOOP
			IF INPUT(I) = ' ' THEN
				RETURN (I - 1);
			ELSIF INPUT(I) = '.' THEN
				RETURN (I - 1);
			ELSIF INPUT(I) = '?' THEN
				RETURN (I - 1);
			END IF;
		END LOOP;
	RETURN 0;
	END GET_TOWER_END;


    -- ########################################################################
    -- RETURNS THE INDEX OF A ? OR A ., IF IT EXISTS. IF IT DOESNT EXIST, RETURN 0
	FUNCTION GET_COMMAND_POSITION( INPUT : STRING; START_INDEX : POSITION; END_INDEX : INTEGER) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..END_INDEX LOOP
			IF INPUT(I) = '.' THEN
				RETURN (I);
			ELSIF INPUT(I) = '?' THEN
				RETURN (I);
			ELSIF INPUT(I) = '#' THEN
				RETURN 0;
			END IF;
		END LOOP;
	RETURN 0;
	END GET_COMMAND_POSITION;


	-- ########################################################################
    -- RETURNS CHARACTER AT AN INDEX
	FUNCTION GET_CHAR_AT_INDEX( INPUT : STRING; INDEX : POSITION) RETURN CHARACTER IS
	BEGIN
		RETURN INPUT(INDEX);
	END GET_CHAR_AT_INDEX;
	
	
	FUNCTION GET_TOWER_NAME( INPUT : STRING; START_INDEX : POSITION; END_INDEX : POSITION ) RETURN STRING IS
	TOWER_NAME : STRING(1..(END_INDEX - START_INDEX + 1));
	BEGIN
		TOWER_NAME := INPUT(START_INDEX..END_INDEX);
		RETURN TOWER_NAME;
	END GET_TOWER_NAME;


BEGIN
    WHILE FOREVER LOOP
		FOR NODE OF SOURCES LOOP
			NODE.CHECKED := FALSE;
		END LOOP;
		ALREADY_PRINTED_DFS := FALSE;
		IS_VALID_INPUT := TRUE;
        ADA.TEXT_IO.GET_LINE(ITEM => INPUT, LAST => LAST); -- Get input
		
		TOWER_FIRST_START := GET_TOWER_START(INPUT, 1);
		TOWER_FIRST_END := GET_TOWER_END(INPUT, TOWER_FIRST_START);
		TOWER_SECOND_START := GET_TOWER_START(INPUT, TOWER_FIRST_END + 1);
		TOWER_SECOND_END := GET_TOWER_END(INPUT, TOWER_SECOND_START);
		COMMAND_INDEX := GET_COMMAND_POSITION(INPUT, TOWER_SECOND_END + 1, 150);
		
		IF COMMAND_INDEX /= 0 THEN
			COMMAND := GET_CHAR_AT_INDEX(INPUT, COMMAND_INDEX);
		ELSE
			IS_VALID_INPUT := FALSE;
		END IF;
		
		IF IS_VALID_INPUT THEN
			PROCESS_STRING(GET_TOWER_NAME(INPUT,TOWER_FIRST_START,TOWER_FIRST_END),
						   GET_TOWER_NAME(INPUT,TOWER_SECOND_START,TOWER_SECOND_END),
						   COMMAND);
		END IF;
    END LOOP;
END HEAR;
