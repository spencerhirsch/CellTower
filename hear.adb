-- Authors: Spencer Hirsch, shirsch2020@my.fit.edu
--          Tyler Gutowski, tgutowski2020@my.fit.edu
-- Course:  CSE 4250, Fall 2022
-- Project: Project 3, Can you HEAR me now?

WITH ADA.TEXT_IO;
WITH ADA.TEXT_IO.UNBOUNDED_IO;
WITH ADA.STRINGS;
WITH ADA.STRINGS.FIXED;
WITH ADA.INTEGER_TEXT_IO;
WITH ADA.CONTAINERS.DOUBLY_LINKED_LISTS;
WITH ADA.STRINGS.UNBOUNDED;
USE ADA.STRINGS.UNBOUNDED;
WITH GRAPH;


-- MAIN PROCEDURE THAT HANDLES ALL OF THE DATA PROCESSING.
-- TAKES INPUT FROM THE USER AND PROCESSES IT ACCORDINGLY.
-- CALLS THE GRAPH FUNCTIONS ACCORDING TO USER INPUT.

PROCEDURE HEAR IS
SUBTYPE POSITION IS INTEGER RANGE 0 .. 150;
	-- PROCEDURE USED TO PROCESS THE INPUT ACCORDINGLY. AFTER THE INPUT IS 
	-- BROKEN APART. THIS PROCEDURE CALLS THE NECESSARY GRAPH OPERATIONS TO
	-- EITHER PROMPT OUTPUT OR TO ADD NEW RECORD TO THE GRAPH.
    PROCEDURE PROCESS_STRING( TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING; COMMAND : CHARACTER ) IS
	LINK_FOUND : BOOLEAN := FALSE;
	TOWER_SOURCE : GRAPH.TOWERS_ACCESS := NEW GRAPH.TOWERS;
	TOWER_CONNECTED : GRAPH.TOWERS_ACCESS := NEW GRAPH.TOWERS;
	FIRST_TOWER_EXISTS : BOOLEAN;
	SECOND_TOWER_EXISTS : BOOLEAN;
	BEGIN
		-- IF USER PROMPTED FOR ADDITION TO GRAPH.
		IF COMMAND = '.' THEN
			FIRST_TOWER_EXISTS := GRAPH.EXISTS_IN_SOURCE(TOWER_FIRST_NAME);
			-- SECOND_TOWER_EXISTS := EXISTS_IN_SOURCE(TOWER_SECOND_NAME); 		-- MIGHT NOT NEED
			IF FIRST_TOWER_EXISTS THEN
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE("ADDING " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " TO " & TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & "'S LINKS");
				TOWER_CONNECTED.SOURCE := TO_UNBOUNDED_STRING(TOWER_SECOND_NAME);
				TOWER_SOURCE := GRAPH.GET_FROM_SOURCE(TOWER_FIRST_NAME);
				TOWER_SOURCE.LINK.APPEND(TOWER_CONNECTED);
				
				-- RETRIEVE ELEMENT RECORD FROM SOURCES LIST TO EDIT
				-- ADD CONNECTING TOWER TO RECORD LIST
			ELSE
				TOWER_SOURCE.SOURCE := TO_UNBOUNDED_STRING(TOWER_FIRST_NAME);		
				TOWER_CONNECTED.SOURCE := TO_UNBOUNDED_STRING(TOWER_SECOND_NAME);
				TOWER_SOURCE.LINK.APPEND(TOWER_CONNECTED);
				GRAPH.SOURCES.APPEND(TOWER_SOURCE);
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE("ADDING " & TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " AND " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " TO GENERAL SOURCE LIST");
			END IF;

			-- SEARCH FOR TOWER_SECCOND NAME
			-- IF EXISTS, COPY CONTENTS INTO ELEMENT_ACCESS AND STORE IN SOURCE RECORD

			-- ELSE
				-- CREATE NEW RECORD FOR CONNECTING TOWER, ADD TO SOURCE RECORD

		ELSIF COMMAND = '?' THEN
			FIRST_TOWER_EXISTS := GRAPH.EXISTS_IN_SOURCE(TOWER_FIRST_NAME);
			SECOND_TOWER_EXISTS := GRAPH.EXISTS_IN_SOURCE(TOWER_SECOND_NAME);
			IF NOT FIRST_TOWER_EXISTS THEN
				ADA.TEXT_IO.PUT_LINE("- " & TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME); 
			ELSIF TOWER_FIRST_NAME = TOWER_SECOND_NAME THEN
				ADA.TEXT_IO.PUT_LINE("+ " & TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
			ELSE
				GRAPH.DFS(TOWER_FIRST_NAME, TOWER_SECOND_NAME, TOWER_FIRST_NAME);

						--NULL;
					--SEARCH ALL CONNECTIONS
			END IF;
			--IF FIRST_TOWER_EXISTS AND SECOND_TOWER_EXISTS THEN
			--	TOWER_SOURCE := GET_FROM_SOURCE(TOWER_FIRST_NAME);
			--	TOWER_CONNECTED := GET_FROM_SOURCE(TOWER_SECOND_NAME);
			--	IF DO_TOWERS_CONNECT(TOWER_SOURCE, TOWER_CONNECTED) THEN
					-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " IS LINKED TO " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME));
			--	ELSE
					-- ADA.TEXT_IO.PUT_LINE("BOTH TOWERS EXIST, BUT THEY DO NOT CONNECT");
			--	END IF;
			--ELSIF FIRST_TOWER_EXISTS AND NOT SECOND_TOWER_EXISTS THEN -- T1 BUT NOT T2
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " DOESNT EXIST");
		--	ELSIF NOT FIRST_TOWER_EXISTS AND SECOND_TOWER_EXISTS THEN -- NOT T1 BUT T2
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " DOESNT EXIST");
		--	ELSIF NOT FIRST_TOWER_EXISTS AND NOT SECOND_TOWER_EXISTS THEN
				-- ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE("NEITHER " & TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) & " NOR " & TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) & " EXIST");
		--	END IF;
			-- SEARCH FOR CONNECTION IN SOURCE LIST			
		END IF;
    END PROCESS_STRING;


    -- ########################################################################
    -- RETURNS THE INDEX OF WHERE A TOWER STARTS
	FUNCTION GET_TOWER_START( INPUT : STRING; START_INDEX : POSITION) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..150 LOOP
			IF INPUT(I) /= ' ' THEN
				RETURN I;
			END IF;
		END LOOP;
	RETURN 0;
	END GET_TOWER_START;
	
	
    -- ########################################################################
    -- RETURNS THE INDEX OF WHERE A TOWER ENDS
	FUNCTION GET_TOWER_END( INPUT : STRING; START_INDEX : POSITION) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..150 LOOP
			IF INPUT(I) = ' ' THEN
				RETURN (I - 1);
			ELSIF INPUT(I) = '.' THEN
				RETURN (I - 1);
			ELSIF INPUT(I) = '?' THEN
				RETURN (I - 1);
			END IF;
		END LOOP;
	RETURN 0;
	END GET_TOWER_END;


    -- ########################################################################
    -- RETURNS THE INDEX OF A ? OR A ., IF IT EXISTS. IF IT DOESNT EXIST, RETURN 0
	FUNCTION GET_COMMAND_POSITION( INPUT : STRING; START_INDEX : POSITION; END_INDEX : INTEGER) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..END_INDEX LOOP
			IF INPUT(I) = '.' THEN
				RETURN (I);
			ELSIF INPUT(I) = '?' THEN
				RETURN (I);
			ELSIF INPUT(I) = '#' THEN
				RETURN 0;
			END IF;
		END LOOP;
	RETURN 0;
	END GET_COMMAND_POSITION;


	-- ########################################################################
    -- RETURNS CHARACTER AT AN INDEX
	FUNCTION GET_CHAR_AT_INDEX( INPUT : STRING; INDEX : POSITION) RETURN CHARACTER IS
	BEGIN
		RETURN INPUT(INDEX);
	END GET_CHAR_AT_INDEX;
	
	
	FUNCTION GET_TOWER_NAME( INPUT : STRING; START_INDEX : POSITION; END_INDEX : POSITION ) RETURN STRING IS
	TOWER_NAME : STRING(1..(END_INDEX - START_INDEX + 1));
	BEGIN
		TOWER_NAME := INPUT(START_INDEX..END_INDEX);
		RETURN TOWER_NAME;
	END GET_TOWER_NAME;

IS_VALID_INPUT     : BOOLEAN                 := TRUE;
LAST               : NATURAL;
FOREVER            : BOOLEAN                 := TRUE;
ARRAY_SIZE         : INTEGER                 := 150;
INPUT              : STRING(1..ARRAY_SIZE);
TOWER_FIRST_START  : POSITION; -- A
TOWER_FIRST_END    : POSITION; -- B
TOWER_SECOND_START : POSITION; -- C
TOWER_SECOND_END   : POSITION; -- D
COMMAND_INDEX      : POSITION; -- E

COMMAND            : CHARACTER;
BEGIN
    WHILE FOREVER LOOP
		FOR NODE OF GRAPH.SOURCES LOOP
			NODE.CHECKED := FALSE;
		END LOOP;
		IS_VALID_INPUT := TRUE;
        ADA.TEXT_IO.GET_LINE(ITEM => INPUT, LAST => LAST); -- Get input
		
		TOWER_FIRST_START := GET_TOWER_START(INPUT, 1);
		TOWER_FIRST_END := GET_TOWER_END(INPUT, TOWER_FIRST_START);
		TOWER_SECOND_START := GET_TOWER_START(INPUT, TOWER_FIRST_END + 1);
		TOWER_SECOND_END := GET_TOWER_END(INPUT, TOWER_SECOND_START);
		COMMAND_INDEX := GET_COMMAND_POSITION(INPUT, TOWER_SECOND_END + 1, 150);
		
		IF COMMAND_INDEX /= 0 THEN
			COMMAND := GET_CHAR_AT_INDEX(INPUT, COMMAND_INDEX);
		ELSE
			IS_VALID_INPUT := FALSE;
		END IF;
		
		IF IS_VALID_INPUT THEN
			PROCESS_STRING(GET_TOWER_NAME(INPUT,TOWER_FIRST_START,TOWER_FIRST_END),
						   GET_TOWER_NAME(INPUT,TOWER_SECOND_START,TOWER_SECOND_END),
						   COMMAND);
		END IF;
    END LOOP;
END HEAR;
