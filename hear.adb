-- Authors: Spencer Hirsch, shirsch2020@my.fit.edu
--          Tyler Gutowski, tgutowski2020@my.fit.edu
-- Course:  CSE 4250, Fall 2022
-- Project: Project 3, Can you HEAR me now?

WITH ADA.TEXT_IO;
WITH ADA.STRINGS;
WITH ADA.STRINGS.FIXED;
WITH ADA.INTEGER_TEXT_IO;
WITH ADA.CONTAINERS.DOUBLY_LINKED_LISTS;
WITH ADA.STRINGS.UNBOUNDED;
USE ADA.STRINGS.UNBOUNDED;
--WITH GRAPH;


-- MAIN PROCEDURE THAT HANDLES ALL OF THE DATA PROCESSING.
-- TAKES INPUT FROM THE USER AND PROCESSES IT ACCORDINGLY.
-- CALLS THE GRAPH FUNCTIONS ACCORDING TO USER INPUT.

PROCEDURE HEAR IS
TYPE TOWERS;								-- DECLARE TYPE
TYPE TOWERS_ACCESS IS ACCESS TOWERS; 		-- REFERNCE TO THE TYPE

-- INITIALIZE DOUBLY LINKED LIST OF TYPE TOWER_ACCESS
PACKAGE LINKS IS NEW ADA.CONTAINERS.DOUBLY_LINKED_LISTS(TOWERS_ACCESS);
USE LINKS;

-- TYPE THAT STORES THE NECESSARY DATA FOR EACH TOWER
-- EACH TOWER HAS A SOURCE AND A LIST OF CONNECTING TOWERS
TYPE TOWERS IS RECORD
	SOURCE : UNBOUNDED_STRING;
	LINK : LIST; 			 				-- LIST OF TOWER_ACCESS
	CHECKED : BOOLEAN := FALSE;
END RECORD;	

-- DECLARE LIST WITHIN SCOPE OF MAIN PROCEDURE
SOURCES : LIST;

SUBTYPE POSITION IS INTEGER RANGE 0 .. 150;
	-- FUNCTION USED TO CHECK TO SEE IF A SOURCE TOWER IS FOUND WITHIN THE SOURCES LIST
	FUNCTION EXISTS_IN_SOURCE (TOWER_FIRST_NAME : STRING) RETURN BOOLEAN IS
	EXISTS : BOOLEAN := FALSE;
	CURRENT_CURSOR : CURSOR;
	CURRENT_TOWER : TOWERS_ACCESS;
	IS_EMPTY_LIST : BOOLEAN := FALSE;
	BEGIN
		IS_EMPTY_LIST := IS_EMPTY(SOURCES);
		IF IS_EMPTY_LIST THEN
			RETURN EXISTS;
		END IF;
		-- CURRENT := SOURCES.FIRST();
		CURRENT_CURSOR := FIRST(SOURCES);
		FOR I IN 1..LENGTH(SOURCES) LOOP
			CURRENT_TOWER := ELEMENT(CURRENT_CURSOR);
			IF CURRENT_TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) THEN
				EXISTS := TRUE;
				ADA.TEXT_IO.PUT_LINE("TOWER FOUND!");
				ADA.TEXT_IO.PUT_LINE(TO_STRING(CURRENT_TOWER.SOURCE));
				RETURN EXISTS;
			ELSE
				ADA.TEXT_IO.PUT_LINE("TOWER NOT FOUND!");
				ADA.TEXT_IO.PUT_LINE(TO_STRING(CURRENT_TOWER.SOURCE));
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN EXISTS;
	END EXISTS_IN_SOURCE;
	

	-- PROCEDURE USED TO PROCESS THE INPUT ACCORDINGLY. AFTER THE INPUT IS 
	-- BROKEN APART. THIS PROCEDURE CALLS THE NECESSARY GRAPH OPERATIONS TO
	-- EITHER PROMPT OUTPUT OR TO ADD NEW RECORD TO THE GRAPH.
    PROCEDURE PROCESS_STRING( TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING; COMMAND : CHARACTER ) IS
	
	TOWER_SOURCE : TOWERS_ACCESS := NEW TOWERS;
	TOWER_CONNECTED : TOWERS_ACCESS := NEW TOWERS;
	FIRST_TOWER_EXISTS : BOOLEAN;
	SECOND_TOWER_EXISTS : BOOLEAN;
	BEGIN
		-- IF USER PROMPTED FOR ADDITION TO GRAPH.
		IF COMMAND = '.' THEN
			FIRST_TOWER_EXISTS := EXISTS_IN_SOURCE(TOWER_FIRST_NAME);
			-- SECOND_TOWER_EXISTS := EXISTS_IN_SOURCE(TOWER_SECOND_NAME); 		-- MIGHT NOT NEED
			IF FIRST_TOWER_EXISTS THEN
				ADA.TEXT_IO.PUT_LINE("source exists, the if statement WORKS");
				TOWER_CONNECTED.SOURCE := TO_UNBOUNDED_STRING(TOWER_SECOND_NAME);
				TOWER_SOURCE.LINK.APPEND(TOWER_CONNECTED);
				
				-- RETRIEVE ELEMENT RECORD FROM SOURCES LIST TO EDIT
				-- ADD CONNECTING TOWER TO RECORD LIST
			ELSE
				TOWER_SOURCE.SOURCE := TO_UNBOUNDED_STRING(TOWER_FIRST_NAME);		
				TOWER_CONNECTED.SOURCE := TO_UNBOUNDED_STRING(TOWER_SECOND_NAME);
				TOWER_SOURCE.LINK.APPEND(TOWER_CONNECTED);
				SOURCES.APPEND(TOWER_SOURCE);
				ADA.TEXT_IO.PUT_LINE("added to source list.");
			END IF;

			-- SEARCH FOR TOWER_SECCOND NAME
			-- IF EXISTS, COPY CONTENTS INTO ELEMENT_ACCESS AND STORE IN SOURCE RECORD

			-- ELSE
				-- CREATE NEW RECORD FOR CONNECTING TOWER, ADD TO SOURCE RECORD

		ELSIF COMMAND = '?' THEN	
			ADA.TEXT_IO.PUT_LINE("QUERY : " & TOWER_FIRST_NAME & " TO " & TOWER_SECOND_NAME);
			-- SEARCH FOR CONNECTION IN SOURCE LIST
		END IF;
    END PROCESS_STRING;


    -- ########################################################################
    -- RETURNS THE INDEX OF WHERE A TOWER STARTS
	FUNCTION GET_TOWER_START( INPUT : STRING; START_INDEX : POSITION) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..150 LOOP
			IF INPUT(I) /= ' ' THEN
				RETURN I;
			END IF;
		END LOOP;
	RETURN 0;
	END GET_TOWER_START;
	
	
    -- ########################################################################
    -- RETURNS THE INDEX OF WHERE A TOWER ENDS
	FUNCTION GET_TOWER_END( INPUT : STRING; START_INDEX : POSITION) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..150 LOOP
			IF INPUT(I) = ' ' THEN
				RETURN (I - 1);
			ELSIF INPUT(I) = '.' THEN
				RETURN (I - 1);
			ELSIF INPUT(I) = '?' THEN
				RETURN (I - 1);
			END IF;
		END LOOP;
	RETURN 0;
	END GET_TOWER_END;


    -- ########################################################################
    -- RETURNS THE INDEX OF A ? OR A ., IF IT EXISTS. IF IT DOESNT EXIST, RETURN 0
	FUNCTION GET_COMMAND_POSITION( INPUT : STRING; START_INDEX : POSITION; END_INDEX : INTEGER) RETURN INTEGER IS
	BEGIN
		FOR I IN START_INDEX..END_INDEX LOOP
			IF INPUT(I) = '.' THEN
				RETURN (I);
			ELSIF INPUT(I) = '?' THEN
				RETURN (I);
			ELSIF INPUT(I) = '#' THEN
				RETURN 0;
			END IF;
		END LOOP;
	RETURN 0;
	END GET_COMMAND_POSITION;


	-- ########################################################################
    -- RETURNS CHARACTER AT AN INDEX
	FUNCTION GET_CHAR_AT_INDEX( INPUT : STRING; INDEX : POSITION) RETURN CHARACTER IS
	BEGIN
		RETURN INPUT(INDEX);
	END GET_CHAR_AT_INDEX;
	
	
	FUNCTION GET_TOWER_NAME( INPUT : STRING; START_INDEX : POSITION; END_INDEX : POSITION ) RETURN STRING IS
	TOWER_NAME : STRING(1..(END_INDEX - START_INDEX + 1));
	BEGIN
		TOWER_NAME := INPUT(START_INDEX..END_INDEX);
		RETURN TOWER_NAME;
	END GET_TOWER_NAME;

IS_VALID_INPUT     : BOOLEAN                 := TRUE;
LAST               : NATURAL;
FOREVER            : BOOLEAN                 := TRUE;
ARRAY_SIZE         : INTEGER                 := 150;
INPUT              : STRING(1..ARRAY_SIZE);
TOWER_FIRST_START  : POSITION; -- A
TOWER_FIRST_END    : POSITION; -- B
TOWER_SECOND_START : POSITION; -- C
TOWER_SECOND_END   : POSITION; -- D
COMMAND_INDEX      : POSITION; -- E

COMMAND            : CHARACTER;
BEGIN
    WHILE FOREVER LOOP
		IS_VALID_INPUT := TRUE;
        ADA.TEXT_IO.GET_LINE(ITEM => INPUT, LAST => LAST); -- Get input
		
		TOWER_FIRST_START := GET_TOWER_START(INPUT, 1);
		TOWER_FIRST_END := GET_TOWER_END(INPUT, TOWER_FIRST_START);
		TOWER_SECOND_START := GET_TOWER_START(INPUT, TOWER_FIRST_END + 1);
		TOWER_SECOND_END := GET_TOWER_END(INPUT, TOWER_SECOND_START);
		COMMAND_INDEX := GET_COMMAND_POSITION(INPUT, TOWER_SECOND_END + 1, 150);
		
		IF COMMAND_INDEX /= 0 THEN
			COMMAND := GET_CHAR_AT_INDEX(INPUT, COMMAND_INDEX);
		ELSE
			IS_VALID_INPUT := FALSE;
		END IF;
		
		IF IS_VALID_INPUT THEN
			PROCESS_STRING(GET_TOWER_NAME(INPUT,TOWER_FIRST_START,TOWER_FIRST_END),
						   GET_TOWER_NAME(INPUT,TOWER_SECOND_START,TOWER_SECOND_END),
						   COMMAND);
		END IF;
    END LOOP;
END HEAR;
