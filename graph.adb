-- Authors: Spencer Hirsch, shirsch2020@my.fit.edu
--          Tyler Gutowski, tgutowski2020@my.fit.edu
-- Course:  CSE 4250, Fall 2022
-- Project: Project 3, Can you HEAR me now?


PACKAGE BODY GRAPH IS
	-- RETURNS BOOLEAN GIVEN THE NAME OF THE SOURCE. CHECKS TO SEE IF SOURCE
	-- EXISTS WITHIN THE SOURCE LIST
	FUNCTION EXISTS_IN_SOURCE (TOWER_FIRST_NAME : STRING) RETURN BOOLEAN IS
	EXISTS : BOOLEAN := FALSE;
	CURRENT_CURSOR : CURSOR;
	CURRENT_TOWER : TOWERS_ACCESS;
	IS_EMPTY_LIST : BOOLEAN := FALSE;
	BEGIN
		IS_EMPTY_LIST := IS_EMPTY(SOURCES);
		IF IS_EMPTY_LIST THEN
			RETURN EXISTS;
		END IF;
		CURRENT_CURSOR := FIRST(SOURCES);
		FOR I IN 1..LENGTH(SOURCES) LOOP
			CURRENT_TOWER := ELEMENT(CURRENT_CURSOR);
			IF CURRENT_TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) THEN
				EXISTS := TRUE;
				RETURN EXISTS;
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN EXISTS;
	END EXISTS_IN_SOURCE;
	

	-- RETURNS TOWER_ACCESS TYPE GIVEN THE FIRST NAME OF THE SOURCE
	FUNCTION GET_FROM_SOURCE ( TOWER_FIRST_NAME : STRING ) RETURN TOWERS_ACCESS IS
	CURRENT_CURSOR : CURSOR;
	CURRENT_TOWER : TOWERS_ACCESS := NULL;
	BEGIN
		CURRENT_CURSOR := FIRST(SOURCES);
		FOR I IN 1..LENGTH(SOURCES) LOOP
			CURRENT_TOWER := ELEMENT(CURRENT_CURSOR);
			IF CURRENT_TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_FIRST_NAME) THEN
				RETURN CURRENT_TOWER;
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN NULL;
	END GET_FROM_SOURCE;
	--t2 > t3
	--t3 > t4
	--t2 ? t4
	--

	PROCEDURE DFS (TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING; TRUE_TOWER_FIRST_NAME : STRING) IS
	CURRENT : TOWERS_ACCESS;
	BEGIN
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME); -- FIND THE SOURCE TOWER OBJECT
		
		CURRENT.CHECKED := TRUE;
		-- PASS CONDITION
		IF CURRENT.SOURCE = TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) AND ALREADY_PRINTED_DFS = FALSE  THEN -- IF YOU ARE SEARCHING THE TOWER YOU WANT
			ADA.TEXT_IO.PUT_LINE("+ " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
			ALREADY_PRINTED_DFS := TRUE;
		
		-- RECURSE
		ELSE
			FOR TOWER OF CURRENT.LINK LOOP -- FOR ALL LINKS IN SOURCE
				IF NOT TOWER.CHECKED THEN -- IF THE LINK HASN'T BEEN CHECKED
					IF GET_FROM_SOURCE(TO_STRING(TOWER.SOURCE)) = NULL AND ALREADY_PRINTED_DFS = FALSE  THEN -- IF WE ARE AT THE END OF THE LINE OR TOWER DOESNT EXIST
						IF TOWER.SOURCE = TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) THEN -- IF WE ARE AT END
							ADA.TEXT_IO.PUT_LINE("+ " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
							ALREADY_PRINTED_DFS := TRUE;
						END IF;
					ELSIF ALREADY_PRINTED_DFS = FALSE THEN -- IF TOWER DOES EXIST, WE ARE NOT AT THE END. CONTINUE RECURSING.
						DFS(TO_STRING(TOWER.SOURCE), TOWER_SECOND_NAME, TRUE_TOWER_FIRST_NAME);
					END IF;
				END IF;
			END LOOP;
		END IF;
		
		-- IF YOU ARE AT THE ROOT TOWER AND YOU HAVENT PRINTED ALREADY
		IF TOWER_FIRST_NAME = TRUE_TOWER_FIRST_NAME AND ALREADY_PRINTED_DFS = FALSE THEN
			ADA.TEXT_IO.PUT_LINE("- " & TRUE_TOWER_FIRST_NAME & " => " & TOWER_SECOND_NAME);
		END IF;
	END DFS;


	-- GIVEN A SOURCE NAME AND A DESTINATION NAME, THIS FUNCTION CHECKS TO SEE IF A CONNECTING TOWER
	-- IS A DIRECT CONNECTION WITH THE SOURCE TOWER. RETURNS A BOOLEAN IF THE CONNECTING TOWER IS
	-- CONTAINED WITHIN THE LIST IN THE TOWERS_ACCESS RECORD
	FUNCTION CHECK_TOWER_LIST(TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING) RETURN BOOLEAN IS
	FOUND : BOOLEAN := FALSE;
	CURRENT_CURSOR : CURSOR;
	CURRENT : TOWERS_ACCESS;
	CURRENT_IN_TOWER : TOWERS_ACCESS;
	BEGIN
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME);
		CURRENT_CURSOR := CURRENT.LINK.FIRST;
		FOR I IN 1..LENGTH(CURRENT.LINK) LOOP
			CURRENT_IN_TOWER := ELEMENT(CURRENT_CURSOR);
			--ADA.TEXT_IO.UNBOUNDED_IO.PUT_LINE(CURRENT_IN_TOWER.SOURCE);
			IF TO_UNBOUNDED_STRING(TOWER_SECOND_NAME) = CURRENT_IN_TOWER.SOURCE THEN
				FOUND := TRUE;
				RETURN FOUND;
			ELSE
				CURRENT_CURSOR := NEXT(CURRENT_CURSOR);
			END IF;
		END LOOP;
		RETURN FOUND;
	END CHECK_TOWER_LIST;




	-- FUNCTION USED TO CHECK ALL POSSIBLE CONNECTS FROM A PARENT SOURCE
	-- EXAMPLE INPUT:
	-- TOWER1 TOWER2 .
	-- TOWER2 TOWER3 .
	-- TOWER1 TOWER3 ? SHOULD RETURN:
	-- + TOWER1 => TOWER3
	-- THIS FUNCTION COVERS THAT CASE A RETURNS
	-- @PARAM DOES_EXIST OF TYPE BOOLEAN
	FUNCTION CHECK_ALL_POSSIBLE(TOWER_FIRST_NAME : STRING; TOWER_SECOND_NAME : STRING) RETURN BOOLEAN IS
		DOES_EXIST : BOOLEAN := FALSE;
		CURRENT_CURSOR : CURSOR;
		CURRENT : TOWERS_ACCESS;
	BEGIN
	
		CURRENT := GET_FROM_SOURCE(TOWER_FIRST_NAME);
		CURRENT_CURSOR := CURRENT.LINK.FIRST;
		FOR I IN 1..LENGTH(CURRENT.LINK) LOOP
			CURRENT := ELEMENT(CURRENT_CURSOR);
			DOES_EXIST := CHECK_TOWER_LIST(TO_STRING(CURRENT.SOURCE), TOWER_SECOND_NAME);
			IF DOES_EXIST THEN
				RETURN DOES_EXIST;
			END IF;
		END LOOP;
		RETURN DOES_EXIST;

	END CHECK_ALL_POSSIBLE;		
END GRAPH;
